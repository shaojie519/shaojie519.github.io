<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Shaojie's Blog]]></title>
  <link href="http://www.shaojie.name/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://www.shaojie.name/"/>
  <updated>2014-03-19T00:40:00+08:00</updated>
  <id>http://www.shaojie.name/</id>
  <author>
    <name><![CDATA[Shao jie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Asynchronous AsyncTask]]></title>
    <link href="http://www.shaojie.name/blog/2014/03/18/android-asynchronous-asynctask/"/>
    <updated>2014-03-18T00:03:02+08:00</updated>
    <id>http://www.shaojie.name/blog/2014/03/18/android-asynchronous-asynctask</id>
    <content type="html"><![CDATA[<h4>AsyncTask介绍</h4>

<p>AsyncTask是Android为我们提供的方便编写异步任务的工具类，可以代替Thread和Handler。但是AsyncTask主要还是用来处理耗时不太长的操作，如果你需要保持一个线程在后台运行很长时间，建议使用java.util.concurrent包下的Executor, ThreadpoolExecutor和FutureTask。
由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下</p>

<ol>
<li>Params
在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</li>
<li>Progress
后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</li>
<li>Result
当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</li>
</ol>


<p>AsyncTask的执行分为四个步骤，每一步都对应一个回调方法，这些方法不应该由应用程序调用，开发者需要做的就是实现这些方法。</p>

<ol>
<li>onPreExecute(), 该方法将在执行实际的后台操作前被UI thread调用。可以在该方法中做一些准备工作，如在界面上显示一个进度条。</li>
<li>doInBackground(Params&hellip;), 将在onPreExecute 方法执行后马上执行，该方法运行在后台线程中。这里将主要负责执行那些很耗时的后台计算工作。可以调用 publishProgress方法来更新实时的任务进度。该方法是抽象方法，子类必须实现。</li>
<li>onProgressUpdate(Progress&hellip;),在publishProgress方法被调用后，UI thread将调用这个方法从而在界面上展示任务的进展情况，例如通过一个进度条进行展示。</li>
<li>onPostExecute(Result), 在doInBackground 执行完成后，onPostExecute 方法将被UI thread调用，后台的计算结果将通过该方法传递到UI thread.</li>
</ol>


<p>为了正确的使用AsyncTask类，以下是几条必须遵守的准则：</p>

<ol>
<li>Task的实例必须在UI thread中创建</li>
<li>execute方法必须在UI thread中调用</li>
<li>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params&hellip;), onProgressUpdate(Progress&hellip;)这几个方法</li>
<li>该task只能被执行一次，否则多次调用时将会出现异常 doInBackground方法和onPostExecute的参数必须对应，这两个参数在AsyncTask声明的泛型参数列表中指定，第一个为doInBackground接受的参数，第二个为显示进度的参数，第三个为doInBackground返回和onPostExecute传入的参数。</li>
</ol>


<p>``` java AsyncTaks <a href="http://www.shaojie.name">http://www.shaojie.name</a>
private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long> {</p>

<pre><code> protected Long doInBackground(URL... urls) {
     int count = urls.length;
     long totalSize = 0;
     for (int i = 0; i &lt; count; i++) {
         totalSize += Downloader.downloadFile(urls[i]);
         publishProgress((int) ((i / (float) count) * 100));
         // Escape early if cancel() is called
         if (isCancelled()) break;
     }
     return totalSize;
 }

 protected void onProgressUpdate(Integer... progress) {
     setProgressPercent(progress[0]);
 }

 protected void onPostExecute(Long result) {
     showDialog("Downloaded " + result + " bytes");
 }
</code></pre>

<p> }
<code>
执行Task:
</code>
new DownloadFilesTask().execute(url1, url2, url3);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Asynchronous HandlerThread]]></title>
    <link href="http://www.shaojie.name/blog/2014/03/17/android-asynchronous-handlerthread/"/>
    <updated>2014-03-17T23:06:29+08:00</updated>
    <id>http://www.shaojie.name/blog/2014/03/17/android-asynchronous-handlerthread</id>
    <content type="html"><![CDATA[<h4>Looper</h4>

<p>Looper是用于给一个线程添加一个消息队列(MessageQueue)，并且循环等待，当有消息时会唤起线程来处理消息的一个工具，直到线程结束为止。通常情况下不会用到Looper，因为对于Activity，Service等系统组件，Frameworks已经为我们初始化好了线程(俗称的UI线程或主线程)，在其内含有一个Looper，和由Looper创建的消息队列，所以主线程会一直运行，处理用户事件，直到某些事件(BACK）退出。
如果，我们需要新建一个线程，并且这个线程要能够循环处理其他线程发来的消息事件，或者需要长期与其他线程进行复杂的交互，这时就需要用到Looper来给线程建立消息队列.</p>

<h5>使用Looper:</h5>

<p>```java  Looper <a href="http://www.shaojie.name">http://www.shaojie.name</a>
  class LooperThread extends Thread {</p>

<pre><code>  public Handler mHandler;

  public void run() {
      Looper.prepare();

      mHandler = new Handler() {
          public void handleMessage(Message msg) {
              // process incoming messages here
          }
      };

      Looper.loop();
  }
</code></pre>

<p>  }
```</p>

<p>这样你的线程就具有了消息处理机制了，在Handler中进行消息处理.
Looper最主要的有四个:
<code>
 public static prepare();
 public static myLooper();
 public static loop();
 public void quit();
</code>
使用方法如下：</p>

<ol>
<li>在每个线程的run()方法中的最开始调用Looper.prepare()，这是为线程初始化消息队列。</li>
<li>之后调用Looper.myLooper()获取此Looper对象的引用。这不是必须的，但是如果你需要保存Looper对象的话，一定要在prepare()之后，否则调用在此对象上的方法不一定有效果，如looper.quit()就不会退出。</li>
<li>在run()方法中添加Handler来处理消息</li>
<li>添加Looper.loop()调用，这是让线程的消息队列开始运行，可以接收消息了。</li>
<li>在想要退出消息循环时，调用Looper.quit()注意，这个方法是要在对象上面调用，很明显，用对象的意思就是要退出具体哪个Looper。如果run()中无其他操作，线程也将终止运行。</li>
</ol>


<h4>Handler</h4>

<p>Handler是用于操作线程内部的消息队列的类。Looper是用于给线程创建消息队列用的，也就是说Looper可以让消息队列(MessageQueue)附属在线程之内，并让消息队列循环起来，接收并处理消息。但，我们并不直接的操作消息队列，而是用Handler来操作消息队列，给消息队列发送消息，和从消息队列中取出消息并处理。这就是Handler的职责。</p>

<p>Handler主要有二个用途，一个是用于线程内部消息循环； 另外一个就是用于线程间通讯，主要方法：
<code>
Handler.sendEmptyMessageDelayed(int msgid, long after);
Handler.sendMessageDelayed(Message msg, long after);
Handler.postDelayed(Runnable task, long after);
Handler.sendMessageAtTime(Message msg, long timeMillis);
Handler.sendEmptyMessageAtTime(int id, long timeMiilis);
Handler.postAtTime(Runnable task, long timeMillis);
</code>
需要注意一点的是，线程内部消息循环并不是并发处理，也就是所有的消息都是在Handler所属的线程内处理的，所以虽然你用post(Runnable r)，发给MessageQueue一个Runnable，但这并不会创建新的线程来执行，处理此消息时仅是调用r.run()。（想要另起线程执行，必须把Runnable放到一个Thread中）。</p>

<h4>Handler</h4>

<p>一般会使用Handler handler = new Handler(){&hellip;}创建Handler。这样创建的handler是在主线程即UI线程下的Handler，
即这个Handler是与UI线程下的默认Looper绑定的。Looper是用于实现消息队列和消息循环机制的。
因此，如果是默认创建Handler那么如果线程是做一些耗时操作如网络获取数据等操作，这样创建Handler是不行的.
Android API提供了HandlerThread来创建线程。官网的解释是：Handy class for starting a new thread that has a looper.
The looper can then be used to create handler classes. Note that start() must still be called.</p>

<p>HandlerThread实际上就一个Thread，只不过它比普通的Thread多了一个Looper。
```
public class HandlerThread extends Thread {
 private int mPriority;
 private int mTid = -1;
 private Looper mLooper;
 &hellip;.
 public void run(){</p>

<pre><code> mTid = Process.myTid();
    Looper.prepare();
    synchronized (this) {
        mLooper = Looper.myLooper();
        Process.setThreadPriority(mPriority);
        notifyAll();
    }
    onLooperPrepared();
    Looper.loop();
    mTid = -1;
</code></pre>

<p> }
 &hellip;.
 }
```</p>

<p>创建HandlerThread时要把它启动了，即调用start()方法。然后创建Handler时将HandlerThread中的looper对象传入。
HandlerThread thread = new HandlerThread(&ldquo;MyHandlerThread&rdquo;);
thread.start();
mHandler = new Handler(thread.getLooper());
mHandler.post(new Runnable(){&hellip;});
那么这个Handler对象就是与HandlerThread这个线程绑定了（这时就不再是与UI线程绑定了，这样它处理耗时操作将不会阻塞UI。</p>

<p>```
private Handler mHandler;
private HandlerThread mHandlerThread;</p>

<p>private boolean mRunning;</p>

<p>private Button btn;</p>

<p>@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

btn = (Button) findViewById(R.id.btn);
btn.setOnClickListener(this);

mHandlerThread = new HandlerThread("Test", 5);
mHandlerThread.start();
mHandler = new Handler(mHandlerThread.getLooper());
</code></pre>

<p>}</p>

<p>private Runnable mRunnable = new Runnable() {</p>

<pre><code>@Override
public void run() {
    while (mRunning) {
        Log.d("MainActivity", "test HandlerThread...");
        try {
            Thread.sleep(200);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
</code></pre>

<p>};</p>

<p>@Override
public void onClick(View v) {</p>

<pre><code>switch(v.getId()) {
case R.id.btn :
    mHandler.post(mRunnable);
    break;
default :
    break;
}
</code></pre>

<p>}</p>

<p>@Override
protected void onDestroy() {</p>

<pre><code>mRunning = false;
mHandler.removeCallbacks(mRunnable);
super.onDestroy();
</code></pre>

<p>}</p>

<p>@Override
protected void onResume() {</p>

<pre><code>mRunning = true;
super.onResume();
</code></pre>

<p>}</p>

<p>@Override
protected void onStop() {</p>

<pre><code>mRunning = false;
super.onStop();
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Asynchronous Executor]]></title>
    <link href="http://www.shaojie.name/blog/2014/03/06/android-asynchronous-executor/"/>
    <updated>2014-03-06T00:22:27+08:00</updated>
    <id>http://www.shaojie.name/blog/2014/03/06/android-asynchronous-executor</id>
    <content type="html"><![CDATA[<p>Executor框架便是Java 5中引入的，其内部使用了线程池机制，它在java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在Java 5之后，通过Executor来启动线程比使用Thread的start方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免this逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用Executor在构造器中。</p>

<p>Executor框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。</p>

<p>Executor接口中之定义了一个方法execute（Runnable command），该方法接收一个Runable实例，它用来执行一个任务，任务即一个实现了Runnable接口的类。</p>

<p><code>java thread http://www.shaojie.name
 Executor executor = anExecutor;
 executor.execute(new RunnableTask1());
 executor.execute(new RunnableTask2());
</code></p>

<p>你可以使用同步的方式，新任务没有启用新线程</p>

<p>``` java thread <a href="http://www.shaojie.name">http://www.shaojie.name</a>
class DirectExecutor implements Executor {
   public void execute(Runnable r) {</p>

<pre><code> r.run();
</code></pre>

<p> }}
```</p>

<p>或者异步的方式，每个新任务启用新线程。</p>

<p>``` java thread <a href="http://www.shaojie.name">http://www.shaojie.name</a>
 class ThreadPerTaskExecutor implements Executor {
   public void execute(Runnable r) {</p>

<pre><code> new Thread(r).start();
</code></pre>

<p> }}
 }}
```</p>

<p>ExecutorService接口继承自Executor接口，它提供了更丰富的实现多线程的方法
ExecutorService是线程池的一个服务，可以随时关闭线程池，是继承Executor的。Executors是个工厂类，专门创建各种线程池。</p>

<p>Android常用的线程池有一下几种，在Executors里面对应的方法：</p>

<h4>newFixedThreadPool</h4>

<p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>

<p>-newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程
-其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子</p>

<p>-和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的），所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器</p>

<p>-从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同:
fixed池线程数固定，并且是0秒IDLE（无IDLE）
cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE</p>

<p><code>java newFixedThreadPool http://www.shaojie.name
　　ExecutorService pool = Executors.newFixedThreadPool(2);
　　//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口
　　Thread t1 = new MyThread();
　　Thread t2 = new MyThread();
　　Thread t3 = new MyThread();
　　Thread t4 = new MyThread();　
　　Thread t5 = new MyThread();
　　//将线程放入池中进行执行
　　pool.execute(t1);
　　pool.execute(t2);
　　pool.execute(t3);
　　pool.execute(t4);
　　pool.execute(t5);
</code>　　
　　</p>

<h4>单任务线程池，newSingleThreadExecutor：</h4>

<p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</p>

<p>-缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中
-缓存型池子通常用于执行一些生存期很短的异步型任务</p>

<p>-能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。
注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</p>

<h4>newSingleThreadExecutor</h4>

<p>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p>

<p>-单例线程，任意时间池中只能有一个线程
-用的是和cache池和fixed池相同的底层池，但线程数目是1,0秒IDLE（无IDLE）</p>

<h4>newScheduledThreadPool</h4>

<p>-调度型线程池
-这个池子里的线程可以按schedule依次delay执行，或周期执行
``` java newScheduledThreadPool <a href="http://shaojie.name">http://shaojie.name</a>
ScheduledExecutorService //执行周期性或定时任务</p>

<p>schedule(Callable<V> callable, long delay, TimeUnit unit) //创建并执行在给定延迟后启用的 ScheduledFuture。</p>

<p>schedule(Runnable command, long delay, TimeUnit unit) //创建并执行在给定延迟后启用的一次性操作。</p>

<p>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnitunit)//创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</p>

<p>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)//创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Asynchronous Thread]]></title>
    <link href="http://www.shaojie.name/blog/2014/03/03/android-asynchronous-Thread/"/>
    <updated>2014-03-03T22:32:57+08:00</updated>
    <id>http://www.shaojie.name/blog/2014/03/03/android-asynchronous-Thread</id>
    <content type="html"><![CDATA[<h3>线程概述</h3>

<p>线程是一个程序的多个执行路径，执行调度的单位，依托于进程存在。 线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。</p>

<h3>线程定义</h3>

<h4>继承java.lang.Thread类</h4>

<p>``` java thread <a href="http://www.shaojie.name">http://www.shaojie.name</a>
public class MyThread extends Thread {</p>

<pre><code>public void run() {
    printf("do something");
}
</code></pre>

<p>}
```</p>

<br>


<p>注意：重写(override)run()方法在该线程的start()方法被调用后，JVM会自动调用run方法来执行任务；但是重载（overload）run()方法，该方法和普通的成员方法一样，并不会因调用该线程的start()方法而被JVM自动运行</p>

<h4>实现java.lang.runnable接口</h4>

<p>```java runnable <a href="http://www.shaojie.name">http://www.shaojie.name</a></p>

<pre><code>public class MyRunnable implements Runnable{
    public void run() {
        printf("do something");
    }
}
</code></pre>

<p>```</p>

<h3>线程的启动</h3>

<h4>1）如果是继承Thread类，则：</h4>

<p>``` java startThread <a href="http://www.shaojie.name">http://www.shaojie.name</a></p>

<pre><code>MyThread thread = new MyThread();
thread.start();
</code></pre>

<p>```</p>

<h4>2)如果实现Runnable接口，则：</h4>

<p>``` java startThread <a href="http://www.shaojie.name">http://www.shaojie.name</a></p>

<pre><code>MyRunnable runnable = new MyRunnable();
Thread t = new Thread(runnable);
t.start();      
</code></pre>

<p>```</p>

<h3>Android提供了从其它线程中访问UI线程：</h3>

<ul>
<li>Activity.runOnUiThread(Runnable);</li>
<li>View.post(Runnable);</li>
<li>View.postDelayed(Runnable);</li>
</ul>


<p>``` java load <a href="http://www.shaojie.name">http://www.shaojie.name</a>
public void onClick(View v) {</p>

<pre><code>new Thread(new Runnable() { 

    public void run() { 

        final Bitmap bitmap = loadImageFromNetwork("http://example.com/image.png"); 

        mImageView.post(new Runnable() { 

            public void run() { 

                mImageView.setImageBitmap(bitmap); 

            } 

        }); 

    } 

}).start(); 
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Asynchronous 介绍]]></title>
    <link href="http://www.shaojie.name/blog/2014/03/03/android-asynchronous-jie-shao/"/>
    <updated>2014-03-03T22:02:37+08:00</updated>
    <id>http://www.shaojie.name/blog/2014/03/03/android-asynchronous-jie-shao</id>
    <content type="html"><![CDATA[<h3>进程与线程</h3>

<p>如果某个应用程序组件是第一次被启动，且这时应用程序也没有其他组件在运行，则Android系统会为应用程序创建一个包含单个线程的linux进程。默认情况下，同一个应用程序的所有组件都运行在同一个进程和线程里（叫做“main”主线程）。如果组件启动时，已经存在应用程序的进程了（因为应用程序的其它组件已经在运行了），则此组件会在已有的进程和线程中启动运行。不过，可以指定组件运行在其他进程里，也可以为任何进程创建额外的线程。</p>

<h4>进程</h4>

<p>默认情况下，同一个应用程序内的所有组件都是运行在同一个进程中的，大部分应用程序也不会去改变它。不过，如果需要指定某个特定组件所属的进程，则可以利用manifest 文件来达到目的。</p>

<p>manifest文件中的每种组件元素——<activity>、 <service>、 <receiver>和<provider>——都支持定义android:process属性，用于指定组件运行的进程。设置此属性即可实现每个组件在各自的进程中运行，或者某几个组件共享一个进程而其它组件运行于独立的进程。设置此属性也可以让不同应用程序的组件运行在同一个进程中——实现多个应用程序共享同一个Linux用户ID、赋予同样的权限。</p>

<p><application>元素也支持android:process属性，用于指定所有组件的默认进程。</p>

<p>如果内存不足，可又有其它为用户提供更紧急服务的进程需要更多内存，Android可能会决定关闭一个进程。在此进程中运行着的应用程序组件也会因此被销毁。当需要再次工作时，会为这些组件重新创建一个进程。</p>

<p>在决定关闭哪个进程的时候，Android系统会权衡它们相对用户的重要程度。比如，相对于一个拥有可见activity的进程，更有可能去关闭一个activity已经在屏幕上看不见的进程。也就是说，是否终止一个进程，取决于运行在此进程中组件的状态。终止进程的判定规则将在后续内容中讨论。</p>

<h3>进程的生命周期</h3>

<p>Android系统试图尽可能长时间地保持应用程序进程，但为了新建或者运行更加重要的进程，总是需要清除过时进程来回收内存。为了决定保留或终止哪个进程，根据进程内运行的组件及这些组件的状态，系统把每个进程都划入一个“重要性层次结构”中。重要性最低的进程首先会被清除，然后是下一个最低的，依此类推，这都是回收系统资源所必需的。</p>

<p>重要性层次结构共有5级，以下列表按照重要程度列出了各类进程（第一类进程是最重要的，将最后一个被终止）：</p>

<h5>1. 前台进程</h5>

<p>用户当前操作所必须的进程。满足以下任一条件时，进程被视作处于前台：</p>

<p>o     其中运行着正与用户交互的Activity（Activity对象的 onResume() 方法已被调用）。</p>

<p>o     其中运行着被正与用户交互的activity绑定的服务Service。</p>

<p>o     其中运行着“前台”服务Service——服务以startForeground()方式被调用。</p>

<p>o     其中运行着正在执行生命周期回调方法（onCreate()、onStart()或onDestroy()）的服务Service。</p>

<p>o     其中运行着正在执行onReceive()方法的BroadcastReceiver。</p>

<p>一般而言，任何时刻前台进程都是为数不多的，只有作为最后的策略——当内存不足以维持它们同时运行时——才会被终止。通常，设备这时候已经到了内存分页状态(memory paging state)的地步，终止一些前台进程是为了保证用户界面的及时响应。</p>

<h4>2. 可见进程</h4>

<p>没有前台组件、但仍会影响用户在屏幕上所见内容的进程。满足以下任一条件时，进程被认为是可见的：</p>

<p>o     其中运行着不在前台的Activity，但用户仍然可见到此activity（onPause()方法被调用了）。比如以下场合就可能发生这种情况：前台activity打开了一个对话框，而之前的activity还允许显示在后面。</p>

<p>o     其中运行着被可见（或前台）activity绑定的服务Service。</p>

<p>可见进程被认为是非常重要的进程，除非无法维持所有前台进程同时运行了，它们是不会被终止的。</p>

<h4>3. 服务进程</h4>

<p>此进程运行着由startService()方法启动的服务，它不会升级为上述两级别。尽管服务进程不直接和用户所见内容关联，但他们通常在执行一些用户关心的操作（比如在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台、可见进程同时运行，系统会保持服务进程的运行。</p>

<h4>4. 后台进程</h4>

<p>包含目前用户不可见activity（Activity对象的onStop()方法已被调用）的进程。这些进程对用户体验没有直接的影响，系统可能在任意时间终止它们，以回收内存供前台进程、可见进程及服务进程使用。通常会有很多后台进程在运行，所以它们被保存在一个LRU（最近最少使用）列表中，以确保最近被用户使用的activity最后一个被终止。如果一个activity正确实现了生命周期方法，并保存了当前的状态，则终止此类进程不会对用户体验产生可见的影响。因为在用户返回时，activity会恢复所有可见的状态。关于保存和恢复状态的详细信息，请参阅Activities文档。</p>

<h4>5. 空进程</h4>

<p>不含任何活动应用程序组件的进程。保留这种进程的唯一目的就是用作缓存，以改善下次在此进程中运行组件的启动时间。为了在进程缓存和内核缓存间平衡系统整体资源，系统经常会终止这种进程。</p>

<p>依据进程中目前活跃组件的重要程度，Android会给进程评估一个尽可能高的级别。例如：如果一个进程中运行着一个服务和一个用户可见的activity，则此进程会被评定为可见进程，而不是服务进程。</p>

<p>此外，一个进程的级别可能会由于其它进程的依赖而被提高——为其它进程提供服务的进程级别永远不会低于使用此服务的进程。比如：如果A进程中的content provider为进程B中的客户端提供服务，或进程A中的服务被进程B中的组件所调用，则A进程至少被视为与进程B同样重要。</p>

<p>因为运行服务的进程级别是高于后台activity进程的，所以，如果activity需要启动一个长时间运行的操作，则为其启动一个服务service会比简单地创建一个工作线程更好些——尤其是在此操作时间比activity本身存在时间还要长久的情况下。比如，一个activity要把图片上传至Web网站，就应该创建一个服务来执行之，即使用户离开了此activity，上传还是会在后台继续运行。不论activity发生什么情况，使用服务可以保证操作至少拥有“服务进程”的优先级。同理，上一篇中的广播接收器broadcast receiver也是使用服务而非线程来处理耗时任务的。</p>

<h3>线程</h3>

<p>应用程序启动时，系统会为它创建一个名为“main”的主线程。主线程非常重要，因为它负责把事件分发给相应的用户界面widget——包括屏幕绘图事件。它也是应用程序与Android UI组件包（来自android.widget和android.view包）进行交互的线程。因此，主线程有时也被叫做UI线程。</p>

<p>系统并不会为每个组件的实例都创建单独的线程。运行于同一个进程中的所有组件都是在UI线程中实例化的，对每个组件的系统调用也都是由UI线程分发的。因此，对系统回调进行响应的方法（比如报告用户操作的onKeyDown()或生命周期回调方法）总是运行在UI线程中。</p>

<p>举个例子，当用户触摸屏幕上的按钮时，应用程序的UI线程把触摸事件分发给widget，widget先把自己置为按下状态，再发送一个显示区域已失效（invalidate）的请求到事件队列中。UI线程从队列中取出此请求，并通知widget重绘自己。</p>

<p>如果应用程序在与用户交互的同时需要执行繁重的任务，单线程模式可能会导致运行性能很低下，除非应用程序的执行时机刚好很合适。如果UI线程需要处理每一件事情，那些耗时很长的操作——诸如访问网络或查询数据库等——将会阻塞整个UI（线程）。一旦线程被阻塞，所有事件都不能被分发，包括屏幕绘图事件。从用户的角度看来，应用程序看上去像是挂起了。更糟糕的是，如果UI线程被阻塞超过一定时间（目前大约是5秒钟），用户就会被提示那个可恶的“应用程序没有响应”(ANR)对话框。如果引起用户不满，他可能就会决定退出并删除这个应用程序。</p>

<p>此外，Andoid的UI组件包并不是线程安全的。因此不允许从工作线程中操作UI——只能从UI线程中操作用户界面。于是，Andoid的单线程模式必须遵守两个规则：</p>

<ol>
<li>不要阻塞UI线程。</li>
<li>不要在UI线程之外访问Andoid的UI组件包。</li>
</ol>


<h3>ANR</h3>

<p>ANR定义：在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现anr，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。</p>

<p>默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。</p>

<h4>第一：什么会引发ANR？</h4>

<p>在Android里，应用程序的响应性是由Activity Manager和WindowManager系统服务监视的 。当它监测到以下情况中的一个时，Android就会针对特定的应用程序显示ANR：
1.在5秒内没有响应输入的事件（例如，按键按下，屏幕触摸）
2.BroadcastReceiver在10秒内没有执行完毕
造成以上两点的原因有很多，比如在主线程中做了非常耗时的操作，比如说是下载，io异常等。</p>

<p>潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者以数据库操作为例，通过异步请求的方式）来完成。然而，不是说你的主线程阻塞在那里等待子线程的完成——也不是调用 Thread.wait()或是Thread.sleep()。替代的方法是，主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。以这种方式设计你的应用程序，将能保证你的主线程保持对输入的响应性并能避免由于5秒输入事件的超时引发的ANR对话框。</p>

<h4>第二：如何避免ANR？</h4>

<ol>
<li><p>运行在主线程里的任何方法都尽可能少做事情。特别是，Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。（可以采用重新开启子线程的方式，然后使用Handler+Message的方式做一些操作，比如更新主线程中的ui等）</p></li>
<li><p>应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。但不再是在子线程里做这些任务（因为 BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个 Service。（此处需要注意的是可以在广播接受者中启动Service，但是却不可以在Service中启动broadcasereciver,关于原因后续会有介绍，此处不是本文重点）</p></li>
<li><p>避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广 播时需要向用户展示什么，你应该使用Notification Manager来实现。</p></li>
</ol>


<h3>后台线程（非UI线程）</h3>

<p>点击按钮下载图片
```</p>

<pre><code>public void onClick(View v){
    Bitmap b = loadImageFormNetWork("http://xxxxx.png");
    mImageView.setImageBitmap(b);
}
</code></pre>

<p>```
上面的代码在UI线程中执行，很容易导致ANR。所以一些耗时的操作，还是用异步方式来处理吧。后面将分别介绍Android平台可以使用的方式。</p>

<ol>
<li>Thread</li>
<li>Executor</li>
<li>HandlerThread</li>
<li>AsyncTask</li>
<li>Service</li>
<li>IntentService</li>
<li>AsyncQuery</li>
<li>Loader</li>
</ol>

]]></content>
  </entry>
  
</feed>
