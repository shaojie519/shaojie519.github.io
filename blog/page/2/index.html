
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Shaojie's Blog</title>
	<meta name="author" content="Shao jie">

	
	<meta name="description" content="Mar 6th, 2014 Android Android Asynchronous Executor Executor框架便是Java 5中引入的，其内部使用了线程池机制，它在java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Shaojie's Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://www.shaojie.name/blog/page/2/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://s.gravatar.com/avatar/f46bfa290cab1bcbb8753835f05b302b?s=160" + MD5("") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">Shaojie's Blog</a></h1>
<p class="subtitle">专注移动开发Android&IOS&PHP&NODEJS</p>
<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/about">About</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/shaojie520" title="Weibo">Weibo</a>
		
		
		
		<a class="google" href="https://plus.google.com/+邵杰" rel="author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/shaojie519" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/shaojie519" title="GitHub">GitHub</a>
		
		
		<a class="dribbble" href="http://www.dribbble.com/shaojie" title="Dribbble">Dribbble</a>
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-03-06T00:22:27+08:00" data-updated="true" itemprop="datePublished">Mar 6<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/android/'>Android</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/03/06/android-asynchronous-executor/" itemprop="url">Android Asynchronous Executor</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Executor框架便是Java 5中引入的，其内部使用了线程池机制，它在java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在Java 5之后，通过Executor来启动线程比使用Thread的start方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免this逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用Executor在构造器中。</p>

<p>Executor框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。</p>

<p>Executor接口中之定义了一个方法execute（Runnable command），该方法接收一个Runable实例，它用来执行一个任务，任务即一个实现了Runnable接口的类。</p>

<figure class='code'><figcaption><span>thread</span><a href='http://www.shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="n">Executor</span> <span class="n">executor</span> <span class="o">=</span> <span class="n">anExecutor</span><span class="o">;</span>
</span><span class='line'> <span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">RunnableTask1</span><span class="o">());</span>
</span><span class='line'> <span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">RunnableTask2</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以使用同步的方式，新任务没有启用新线程</p>

<figure class='code'><figcaption><span>thread</span><a href='http://www.shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">DirectExecutor</span> <span class="kd">implements</span> <span class="n">Executor</span> <span class="o">{</span>
</span><span class='line'>   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span><span class='line'> <span class="o">}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者异步的方式，每个新任务启用新线程。</p>

<figure class='code'><figcaption><span>thread</span><a href='http://www.shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">class</span> <span class="nc">ThreadPerTaskExecutor</span> <span class="kd">implements</span> <span class="n">Executor</span> <span class="o">{</span>
</span><span class='line'>   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
</span><span class='line'> <span class="o">}}</span>
</span><span class='line'> <span class="o">}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ExecutorService接口继承自Executor接口，它提供了更丰富的实现多线程的方法
ExecutorService是线程池的一个服务，可以随时关闭线程池，是继承Executor的。Executors是个工厂类，专门创建各种线程池。</p>

<p>Android常用的线程池有一下几种，在Executors里面对应的方法：</p>

<h4>newFixedThreadPool</h4>

<p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>

<p>-newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程
-其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子</p>

<p>-和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的），所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器</p>

<p>-从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同:
fixed池线程数固定，并且是0秒IDLE（无IDLE）
cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE</p>

<figure class='code'><figcaption><span>newFixedThreadPool</span><a href='http://www.shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="err">　　</span><span class="n">ExecutorService</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
</span><span class='line'><span class="err">　　</span><span class="c1">//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span>
</span><span class='line'><span class="err">　　</span><span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">();</span>
</span><span class='line'><span class="err">　　</span><span class="n">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">();</span>
</span><span class='line'><span class="err">　　</span><span class="n">Thread</span> <span class="n">t3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">();</span>
</span><span class='line'><span class="err">　　</span><span class="n">Thread</span> <span class="n">t4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">();</span><span class="err">　</span>
</span><span class='line'><span class="err">　　</span><span class="n">Thread</span> <span class="n">t5</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">();</span>
</span><span class='line'><span class="err">　　</span><span class="c1">//将线程放入池中进行执行</span>
</span><span class='line'><span class="err">　　</span><span class="n">pool</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">t1</span><span class="o">);</span>
</span><span class='line'><span class="err">　　</span><span class="n">pool</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">t2</span><span class="o">);</span>
</span><span class='line'><span class="err">　　</span><span class="n">pool</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">t3</span><span class="o">);</span>
</span><span class='line'><span class="err">　　</span><span class="n">pool</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">t4</span><span class="o">);</span>
</span><span class='line'><span class="err">　　</span><span class="n">pool</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">t5</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>　　
　　</p>

<h4>单任务线程池，newSingleThreadExecutor：</h4>

<p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</p>

<p>-缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中
-缓存型池子通常用于执行一些生存期很短的异步型任务</p>

<p>-能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。
注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</p>

<h4>newSingleThreadExecutor</h4>

<p>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p>

<p>-单例线程，任意时间池中只能有一个线程
-用的是和cache池和fixed池相同的底层池，但线程数目是1,0秒IDLE（无IDLE）</p>

<h4>newScheduledThreadPool</h4>

<p>-调度型线程池
-这个池子里的线程可以按schedule依次delay执行，或周期执行</p>

<figure class='code'><figcaption><span>newScheduledThreadPool</span><a href='http://shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">ScheduledExecutorService</span> <span class="c1">//执行周期性或定时任务</span>
</span><span class='line'>
</span><span class='line'><span class="n">schedule</span><span class="o">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">callable</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delay</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="c1">//创建并执行在给定延迟后启用的 ScheduledFuture。</span>
</span><span class='line'>
</span><span class='line'><span class="n">schedule</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delay</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="c1">//创建并执行在给定延迟后启用的一次性操作。</span>
</span><span class='line'>
</span><span class='line'><span class="n">scheduleAtFixedRate</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">,</span> <span class="kt">long</span> <span class="n">initialDelay</span><span class="o">,</span> <span class="kt">long</span> <span class="n">period</span><span class="o">,</span> <span class="n">TimeUnitunit</span><span class="o">)</span><span class="c1">//创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</span>
</span><span class='line'>
</span><span class='line'><span class="n">scheduleWithFixedDelay</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">,</span> <span class="kt">long</span> <span class="n">initialDelay</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delay</span><span class="o">,</span><span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span><span class="c1">//创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</span>
</span></code></pre></td></tr></table></div></figure>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-03-03T22:32:57+08:00" data-updated="true" itemprop="datePublished">Mar 3<span>rd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/android/'>Android</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/03/03/android-asynchronous-Thread/" itemprop="url">Android Asynchronous Thread</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>线程概述</h3>

<p>线程是一个程序的多个执行路径，执行调度的单位，依托于进程存在。 线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。</p>

<h3>线程定义</h3>

<h4>继承java.lang.Thread类</h4>

<figure class='code'><figcaption><span>thread</span><a href='http://www.shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="o">(</span><span class="s">&quot;do something&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<br>


<p>注意：重写(override)run()方法在该线程的start()方法被调用后，JVM会自动调用run方法来执行任务；但是重载（overload）run()方法，该方法和普通的成员方法一样，并不会因调用该线程的start()方法而被JVM自动运行</p>

<h4>实现java.lang.runnable接口</h4>

<figure class='code'><figcaption><span>runnable</span><a href='http://www.shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="o">(</span><span class="s">&quot;do something&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>线程的启动</h3>

<h4>1）如果是继承Thread类，则：</h4>

<figure class='code'><figcaption><span>startThread</span><a href='http://www.shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">MyThread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">();</span>
</span><span class='line'><span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<h4>2)如果实现Runnable接口，则：</h4>

<figure class='code'><figcaption><span>startThread</span><a href='http://www.shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">MyRunnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyRunnable</span><span class="o">();</span>
</span><span class='line'><span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>       
</span></code></pre></td></tr></table></div></figure>


<h3>Android提供了从其它线程中访问UI线程：</h3>

<ul>
<li>Activity.runOnUiThread(Runnable);</li>
<li>View.post(Runnable);</li>
<li>View.postDelayed(Runnable);</li>
</ul>


<figure class='code'><figcaption><span>load</span><a href='http://www.shaojie.name'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="kd">final</span> <span class="n">Bitmap</span> <span class="n">bitmap</span> <span class="o">=</span> <span class="n">loadImageFromNetwork</span><span class="o">(</span><span class="s">&quot;http://example.com/image.png&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">mImageView</span><span class="o">.</span><span class="na">post</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>                    <span class="n">mImageView</span><span class="o">.</span><span class="na">setImageBitmap</span><span class="o">(</span><span class="n">bitmap</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="o">});</span>
</span><span class='line'>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-03-03T22:02:37+08:00" data-updated="true" itemprop="datePublished">Mar 3<span>rd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/android/'>Android</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/03/03/android-asynchronous-jie-shao/" itemprop="url">Android Asynchronous 介绍</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>进程与线程</h3>

<p>如果某个应用程序组件是第一次被启动，且这时应用程序也没有其他组件在运行，则Android系统会为应用程序创建一个包含单个线程的linux进程。默认情况下，同一个应用程序的所有组件都运行在同一个进程和线程里（叫做“main”主线程）。如果组件启动时，已经存在应用程序的进程了（因为应用程序的其它组件已经在运行了），则此组件会在已有的进程和线程中启动运行。不过，可以指定组件运行在其他进程里，也可以为任何进程创建额外的线程。</p>

<h4>进程</h4>

<p>默认情况下，同一个应用程序内的所有组件都是运行在同一个进程中的，大部分应用程序也不会去改变它。不过，如果需要指定某个特定组件所属的进程，则可以利用manifest 文件来达到目的。</p>

<p>manifest文件中的每种组件元素——<activity>、 <service>、 <receiver>和<provider>——都支持定义android:process属性，用于指定组件运行的进程。设置此属性即可实现每个组件在各自的进程中运行，或者某几个组件共享一个进程而其它组件运行于独立的进程。设置此属性也可以让不同应用程序的组件运行在同一个进程中——实现多个应用程序共享同一个Linux用户ID、赋予同样的权限。</p>

<p><application>元素也支持android:process属性，用于指定所有组件的默认进程。</p>

<p>如果内存不足，可又有其它为用户提供更紧急服务的进程需要更多内存，Android可能会决定关闭一个进程。在此进程中运行着的应用程序组件也会因此被销毁。当需要再次工作时，会为这些组件重新创建一个进程。</p>

<p>在决定关闭哪个进程的时候，Android系统会权衡它们相对用户的重要程度。比如，相对于一个拥有可见activity的进程，更有可能去关闭一个activity已经在屏幕上看不见的进程。也就是说，是否终止一个进程，取决于运行在此进程中组件的状态。终止进程的判定规则将在后续内容中讨论。</p>

<h3>进程的生命周期</h3>

<p>Android系统试图尽可能长时间地保持应用程序进程，但为了新建或者运行更加重要的进程，总是需要清除过时进程来回收内存。为了决定保留或终止哪个进程，根据进程内运行的组件及这些组件的状态，系统把每个进程都划入一个“重要性层次结构”中。重要性最低的进程首先会被清除，然后是下一个最低的，依此类推，这都是回收系统资源所必需的。</p>

<p>重要性层次结构共有5级，以下列表按照重要程度列出了各类进程（第一类进程是最重要的，将最后一个被终止）：</p>

<h5>1. 前台进程</h5>

<p>用户当前操作所必须的进程。满足以下任一条件时，进程被视作处于前台：</p>

<p>o     其中运行着正与用户交互的Activity（Activity对象的 onResume() 方法已被调用）。</p>

<p>o     其中运行着被正与用户交互的activity绑定的服务Service。</p>

<p>o     其中运行着“前台”服务Service——服务以startForeground()方式被调用。</p>

<p>o     其中运行着正在执行生命周期回调方法（onCreate()、onStart()或onDestroy()）的服务Service。</p>

<p>o     其中运行着正在执行onReceive()方法的BroadcastReceiver。</p>

<p>一般而言，任何时刻前台进程都是为数不多的，只有作为最后的策略——当内存不足以维持它们同时运行时——才会被终止。通常，设备这时候已经到了内存分页状态(memory paging state)的地步，终止一些前台进程是为了保证用户界面的及时响应。</p>

<h4>2. 可见进程</h4>

<p>没有前台组件、但仍会影响用户在屏幕上所见内容的进程。满足以下任一条件时，进程被认为是可见的：</p>

<p>o     其中运行着不在前台的Activity，但用户仍然可见到此activity（onPause()方法被调用了）。比如以下场合就可能发生这种情况：前台activity打开了一个对话框，而之前的activity还允许显示在后面。</p>

<p>o     其中运行着被可见（或前台）activity绑定的服务Service。</p>

<p>可见进程被认为是非常重要的进程，除非无法维持所有前台进程同时运行了，它们是不会被终止的。</p>

<h4>3. 服务进程</h4>

<p>此进程运行着由startService()方法启动的服务，它不会升级为上述两级别。尽管服务进程不直接和用户所见内容关联，但他们通常在执行一些用户关心的操作（比如在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台、可见进程同时运行，系统会保持服务进程的运行。</p>

<h4>4. 后台进程</h4>

<p>包含目前用户不可见activity（Activity对象的onStop()方法已被调用）的进程。这些进程对用户体验没有直接的影响，系统可能在任意时间终止它们，以回收内存供前台进程、可见进程及服务进程使用。通常会有很多后台进程在运行，所以它们被保存在一个LRU（最近最少使用）列表中，以确保最近被用户使用的activity最后一个被终止。如果一个activity正确实现了生命周期方法，并保存了当前的状态，则终止此类进程不会对用户体验产生可见的影响。因为在用户返回时，activity会恢复所有可见的状态。关于保存和恢复状态的详细信息，请参阅Activities文档。</p>

<h4>5. 空进程</h4>

<p>不含任何活动应用程序组件的进程。保留这种进程的唯一目的就是用作缓存，以改善下次在此进程中运行组件的启动时间。为了在进程缓存和内核缓存间平衡系统整体资源，系统经常会终止这种进程。</p>

<p>依据进程中目前活跃组件的重要程度，Android会给进程评估一个尽可能高的级别。例如：如果一个进程中运行着一个服务和一个用户可见的activity，则此进程会被评定为可见进程，而不是服务进程。</p>

<p>此外，一个进程的级别可能会由于其它进程的依赖而被提高——为其它进程提供服务的进程级别永远不会低于使用此服务的进程。比如：如果A进程中的content provider为进程B中的客户端提供服务，或进程A中的服务被进程B中的组件所调用，则A进程至少被视为与进程B同样重要。</p>

<p>因为运行服务的进程级别是高于后台activity进程的，所以，如果activity需要启动一个长时间运行的操作，则为其启动一个服务service会比简单地创建一个工作线程更好些——尤其是在此操作时间比activity本身存在时间还要长久的情况下。比如，一个activity要把图片上传至Web网站，就应该创建一个服务来执行之，即使用户离开了此activity，上传还是会在后台继续运行。不论activity发生什么情况，使用服务可以保证操作至少拥有“服务进程”的优先级。同理，上一篇中的广播接收器broadcast receiver也是使用服务而非线程来处理耗时任务的。</p>

<h3>线程</h3>

<p>应用程序启动时，系统会为它创建一个名为“main”的主线程。主线程非常重要，因为它负责把事件分发给相应的用户界面widget——包括屏幕绘图事件。它也是应用程序与Android UI组件包（来自android.widget和android.view包）进行交互的线程。因此，主线程有时也被叫做UI线程。</p>

<p>系统并不会为每个组件的实例都创建单独的线程。运行于同一个进程中的所有组件都是在UI线程中实例化的，对每个组件的系统调用也都是由UI线程分发的。因此，对系统回调进行响应的方法（比如报告用户操作的onKeyDown()或生命周期回调方法）总是运行在UI线程中。</p>

<p>举个例子，当用户触摸屏幕上的按钮时，应用程序的UI线程把触摸事件分发给widget，widget先把自己置为按下状态，再发送一个显示区域已失效（invalidate）的请求到事件队列中。UI线程从队列中取出此请求，并通知widget重绘自己。</p>

<p>如果应用程序在与用户交互的同时需要执行繁重的任务，单线程模式可能会导致运行性能很低下，除非应用程序的执行时机刚好很合适。如果UI线程需要处理每一件事情，那些耗时很长的操作——诸如访问网络或查询数据库等——将会阻塞整个UI（线程）。一旦线程被阻塞，所有事件都不能被分发，包括屏幕绘图事件。从用户的角度看来，应用程序看上去像是挂起了。更糟糕的是，如果UI线程被阻塞超过一定时间（目前大约是5秒钟），用户就会被提示那个可恶的“应用程序没有响应”(ANR)对话框。如果引起用户不满，他可能就会决定退出并删除这个应用程序。</p>

<p>此外，Andoid的UI组件包并不是线程安全的。因此不允许从工作线程中操作UI——只能从UI线程中操作用户界面。于是，Andoid的单线程模式必须遵守两个规则：</p>

<ol>
<li>不要阻塞UI线程。</li>
<li>不要在UI线程之外访问Andoid的UI组件包。</li>
</ol>


<h3>ANR</h3>

<p>ANR定义：在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现anr，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。</p>

<p>默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。</p>

<h4>第一：什么会引发ANR？</h4>

<p>在Android里，应用程序的响应性是由Activity Manager和WindowManager系统服务监视的 。当它监测到以下情况中的一个时，Android就会针对特定的应用程序显示ANR：
1.在5秒内没有响应输入的事件（例如，按键按下，屏幕触摸）
2.BroadcastReceiver在10秒内没有执行完毕
造成以上两点的原因有很多，比如在主线程中做了非常耗时的操作，比如说是下载，io异常等。</p>

<p>潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者以数据库操作为例，通过异步请求的方式）来完成。然而，不是说你的主线程阻塞在那里等待子线程的完成——也不是调用 Thread.wait()或是Thread.sleep()。替代的方法是，主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。以这种方式设计你的应用程序，将能保证你的主线程保持对输入的响应性并能避免由于5秒输入事件的超时引发的ANR对话框。</p>

<h4>第二：如何避免ANR？</h4>

<ol>
<li><p>运行在主线程里的任何方法都尽可能少做事情。特别是，Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。（可以采用重新开启子线程的方式，然后使用Handler+Message的方式做一些操作，比如更新主线程中的ui等）</p></li>
<li><p>应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。但不再是在子线程里做这些任务（因为 BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个 Service。（此处需要注意的是可以在广播接受者中启动Service，但是却不可以在Service中启动broadcasereciver,关于原因后续会有介绍，此处不是本文重点）</p></li>
<li><p>避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广 播时需要向用户展示什么，你应该使用Notification Manager来实现。</p></li>
</ol>


<h3>后台线程（非UI线程）</h3>

<p>点击按钮下载图片</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void onClick(View v){
</span><span class='line'>  Bitmap b = loadImageFormNetWork("http://xxxxx.png");
</span><span class='line'>  mImageView.setImageBitmap(b);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码在UI线程中执行，很容易导致ANR。所以一些耗时的操作，还是用异步方式来处理吧。后面将分别介绍Android平台可以使用的方式。</p>

<ol>
<li>Thread</li>
<li>Executor</li>
<li>HandlerThread</li>
<li>AsyncTask</li>
<li>Service</li>
<li>IntentService</li>
<li>AsyncQuery</li>
<li>Loader</li>
</ol>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-02-27T23:36:54+08:00" data-updated="true" itemprop="datePublished">Feb 27<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/github/'>Github</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/02/27/github-search-syntax/" itemprop="url">GitHub Search Syntax</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>Search Syntax</h3>

<p>如果你想精确的查找搜索结果，你可以一直使用<a href="/blog/2014/02/23/advanced-search/">高级搜索</a>,但是，使用正确的搜索语法可以帮助你更快速的找到你想要的结果，下面就介绍几种搜索语法。</p>

<h4>Greater Than Queries</h4>

<p>设想你想找所有与‘cats’有关的项目，而且筛选出它被用户标记星号(stars)的次数大于10次。你可以使用一些操作符帮助你完成。</p>

<p><p>><code>&gt;</code> 和 <code>&gt;=</code>符号代表“大于”和&#8221;大于等于&#8221;。例如下边的两个例子是等价的
<p>><code>cats stars:"&gt;10"</code>
<p>><code>cats stars:"&gt;=10"</code>
<br>
<br>
<p>>你也可以使用更加程序化的符号<code>..*</code>,它等价于<code>&gt;=</code>,代表查找所有大于等于10的。
<p>><code>cats stars:"10..*"</code>
<br>
<br></p>

<p><p>>符号<code>*</code>可以代表任意数字，所以<code>10 .. 50</code>等价于&#8221;所有大约等于10取小于等于50&#8221;。</p>

<h4>Less Than Queries</h4>

<p>如果你想找所有与‘cats’有关的项目，而且筛选出它被用户标记星号(stars)的次数小于10次。你可以使用类似的一些操作符帮助你完成。
<p>><code>&lt;</code> 和 <code>&lt;=</code>符号代表“小于”和&#8221;小于等于&#8221;。例如下边的两个例子是等价的
<p>><code>cats stars:"&lt;10"</code>
<p>><code>cats stars:"&lt;=9"</code>
<br>
<br>
<p>>你也可以使用更加程序化的符号<code>*..</code>,它等价于<code>&lt;=</code>,代表查找所有小等于10的。
<p>><code>cats stars:"*..10"</code>
<br>
<br></p>

<p><p>>符号<code>*</code>可以代表任意数字，所以<code>1 .. 10</code>等价于&#8221;所有大约等于1取小于等于10&#8221;。</p>

<h4>Range Queries</h4>

<p>当你要查找一些没有‘数量’标记的项目时，range查询这时就能显出2它的威力来了，比如你还是要查找与&#8217;cat&#8217;相关的项目，并且上次的更新时间在2014年1月低到今天的2014年2月28
<p>><code>cats pushed:2014-01-31..2014-02-28</code></p>

<h4>Omitting Spaces</h4>

<p>如果你更倾向更短的标记和更少的字符的话，你可以删除引号以及查询条件中多余的空格，仅当查询的条件中包含空格的时候才需要引号
<p>><code>cats stars:&gt;10</code>
<p>><code>cats stars:&lt;10</code>
<p>><code>cats pushed:2014-01-30..2014-02-28</code></p>

<h4>The power of NOT</h4>

<p>你可以使用<code>NOT</code>符号从你的搜索条件中排除关键字的项目，比如搜索···Hello···会返回很多包含<code>Hello World</code>相关的项目，但是如果在搜索条件中加入NOT像这样：
<p>><code>Hello NOT World</code>
<p>就会过滤掉排除包含<code>World</code>的。
<p><code>`NOT</code>符号只能用于String类型的关键字</p>

<h4>Filtering using Exclusion</h4>

<p>另一种缩小搜索范围的方式是排除子集。在搜索的条件的前面带上<code>-</code>，就能排除所有符合条件的结果集
<p>比如你想查找所有包含&#8217;cats&#8217;并且&#8217;stars&#8217;数量大于10并且不使用&#8217;javascript&#8217;
<p>><code>cats stars:&gt;10 -language:javascript</code></p>

<p><p>查找所有没有@defunkt的issues:
<p>><code>mentions:defunkt -user:github</code></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-02-23T01:24:57+08:00" data-updated="true" itemprop="datePublished">Feb 23<span>rd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/github/'>Github</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/02/23/advanced-search/" itemprop="url">Github高级搜索</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>Advanced Search</h3>

<p>使用<a href="https://github.com/search/advanced">高级搜索</a>可以让你近一步缩小搜索范围，你可以通过stars数目、forks数目、文件后缀名等过滤。当你在条件输入框填写条件的时候，它会自动的把高级查询拼接到上面的输入框中。</p>

<p><img src="https://github-images.s3.amazonaws.com/help/search/advanced_search.png" alt="Github " /></p>

<h3>总结</h3>

<p>关于高级查询，我们可以指定很多的参数，以方便我们快速查询，下一篇介绍<a href="/blog/2014/02/27/github-search-syntax/">搜索语法</a>;</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-02-22T23:41:43+08:00" data-updated="true" itemprop="datePublished">Feb 22<span>nd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/github/'>Github</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/02/22/searching-github/" itemprop="url">Searching Github</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>Searching Github</h3>

<p><p>目前Gihtub上有数以万计的开源项目、用户、代码段，要想从中搜索到自己想要的真是件让人头疼的事情。幸好，有一些搜索技巧可以帮助你快速找到你的结果。</p>

<h3>Find all the Things</h3>

<p><a href="https://github.com/search">Github Search</a> 的功能是基于<a href="https://help.github.com/articles/using-the-command-bar">CommandBar</a>。你可以输入任何你想要的查询条件，它会把所有符合条件的结果高亮显示出来。你也可以点击左侧选择一种编程语言或者点击搜索结果项目列表来进一步缩小搜索范围。</p>

<p>在这个搜索引擎下，搜索就像一个弹性的搜索集合，当有push代码到Github你就可以实时的检索到它们。这些结果来自Github上的开源项目，也包括你有权限操作的私有项目。</p>

<p>为了让搜索关联性更加准确，Github很保守的给出搜索索引，例如，forks的项目一般是不会被搜索出来的，除非这个项目比原始项目有更多的stars。</p>

<p><img src="https://github-images.s3.amazonaws.com/help/search/search_overview.png" alt="Github " /></p>

<h3>搜索类型</h3>

<h4>项目（Repositories）</h4>

<p>每个搜索项目都有一个项目活动的展示，这个可以帮助你找到一些活跃的项目，当然也包括你的私有项目
当你的搜索结果很多足有好几页的搜索结果，你可以对这些结果按照条件进行排序以便更容易找到结果</p>

<p>关于更好的搜索项目相关说明，你查看<a href="/https://help.github.com/articles/searching-repositories">搜索项目</a></p>

<h4>问题(Issues)</h4>

<p>Issues search可以让你浏览所有的public的项目以及你有权限的私有项目的问答。你可以选择查看某个组织的问答，也可以选择与某个用户相关的问答。</p>

<p>更多关于如何查找问题。请查看<a href="/https://help.github.com/articles/searching-issues">搜索问题</a></p>

<h4>代码(code)</h4>

<p>代码搜索可以让你查看所有的public项目以及你有权限的私有项目的代码。你可以带上下边的参数</p>

<ul>
<li>搜索结果的行号</li>
<li>代码语法的高亮显示</li>
<li>上次检索时间</li>
<li>通过文件后缀查找</li>
<li>通过路径查找</li>
<li>只查找我自己的项目</li>
</ul>


<p>更多关于如何搜索代码，请查看<a href="/https://help.github.com/articles/searching-code">代码搜索</a></p>

<h4>用户(Users)</h4>

<p>用户搜索界面包含所有你要的一切：精确的结果、你可以直接Follow这些用户
更多关于如果搜索用户，请查看<a href="/https://help.github.com/articles/searching-users">搜索用户</a></p>

<h3>结果排序</h3>

<p>默认，Github搜索结果以搜索匹配(best match)降序排序的，当然你也可以选择其他的排序方式。比如，你可以现在按照 Star fork 数量排序。对于问答（Issues），你可以按照创建时间或者更新时间排序</p>

<h3>总结</h3>

<p>Github Seaching基本的内容介绍完了，下一篇<a href="/blog/2014/02/23/advanced-search/">高级搜索</a>;</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-02-16T00:33:40+08:00" data-updated="true" itemprop="datePublished">Feb 16<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/other/'>Other</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/02/16/da-jian-bo-ke-huan-jing/" itemprop="url">搭建博客环境</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>1.Octopress需要Ruby环境，RVM(Ruby Version Manager)负责安装和管理Ruby的环境。所以我们先在终端输入如下命令，来安装RVM</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -L https://get.rvm.io | bash -s stable --ruby</span></code></pre></td></tr></table></div></figure>


<p>安装ruby1.9.3</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rvm install 1.9.3
</span><span class='line'>rvm use 1.9.3
</span><span class='line'>rvm rubygems lastest</span></code></pre></td></tr></table></div></figure>


<h3>2.安装Octpress</h3>

<p>在安装octpress之前，确保安装了git。
下载octpress</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octopress
</span><span class='line'>cd octpress</span></code></pre></td></tr></table></div></figure>


<p>安装相关依赖</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem install bundler
</span><span class='line'>rbenv rehash
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<p>安装默认的Octpress主题</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<h3>3.将博客部署到Github上</h3>

<p>Github的Page service可以免费托管博客，并且还可以自定义域名。</p>

<p>首先需要在GitHub上创建一个仓库，并将仓库名称按照这样的方式进行命名：<code>username.github.com</code>或<code>organization.github.com</code>。等后面配置完毕之后，我们就可以在浏览器中使用页面地址<code>http://username.github.com</code>来访问我们的博客。一般来说，我们希望在将博客的源码放到source分支下，并把生成的内容提交到master分支。</p>

<p>创建好仓库之后，我们需要利用octopress的一个配置rake任务来自动配置上面创建的仓库：可以让我们方便的部署GitHub page。在终端输入如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>完成上面的命令之后，我们就可以生成博客并真正的部署到仓库中了。执行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>现在可以访问<code>http://username.github.com</code>了。注意：有时候可能会有延时，要等等10分钟左右才能打开。</p>

<p>不过博客的source需要单独提交，执行如下命令就可以将source提交到仓库的source分支下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'Initial souece comment'
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<p>如果在部署到仓库之前，需要先预览一下博客，可以在终端输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>然后就能在浏览器中进行本地预览访问了：<code>http://127.0.0.1:4000/</code>或<code>http://localhost:4000/</code>，效果跟仓库中的一样。</p>

<h3>4.开始写博客</h3>

<p>新建一篇文章</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake 'new_post[title]'
</span><span class='line'>其中title为博文的文件名，创建出来的文件默认是markdown格式。上面的命令会创建出这样一个文件：source/_posts/2014-2-16-title.markdown</span></code></pre></td></tr></table></div></figure>


<p>打开这篇文章，可以看到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: post
</span><span class='line'>title: title
</span><span class='line'>date: 2014-0-16 00:33:40 +0800
</span><span class='line'>comments: true
</span><span class='line'>categoryies:
</span><span class='line'>---</span></code></pre></td></tr></table></div></figure>


<p>categories 填写文章的分类名</p>

<p>接着我们就可以在这个文件中写我们的博文。完成之后，我们可以预览和部署博文。下面是创建并部署博文的一个完整过程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake 'new_post[title]'
</span><span class='line'>rake generate
</span><span class='line'>git add .
</span><span class='line'>git commit -am "add new post"
</span><span class='line'>git push origin source
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<h3>5.添加分类列表</h3>

<p>保存一下代码到 plugins/category_list_tag.rb:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module Jekyll
</span><span class='line'>  class CategoryListTag &lt; Liquid::Tag
</span><span class='line'>    def render(context)
</span><span class='line'>      html = ""
</span><span class='line'>      categories = context.registers[:site].categories.keys
</span><span class='line'>      categories.sort.each do |category|
</span><span class='line'>        posts_in_category = context.registers[:site].categories[category].size
</span><span class='line'>        category_dir = context.registers[:site].config['category_dir']
</span><span class='line'>        category_url = File.join(category_dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').downcase)
</span><span class='line'>        html &lt;&lt; "&lt;li class='category'&gt;&lt;a href='/#{category_url}/'&gt;#{category} (#{posts_in_category})&lt;/a&gt;&lt;/li&gt;\n"
</span><span class='line'>      end
</span><span class='line'>      html
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>Liquid::Template.register_tag('category_list', Jekyll::CategoryListTag)</span></code></pre></td></tr></table></div></figure>


<p>这个插件会向liquid注册一个名为category_list的tag，该tag就是以li的形式将站点所有的category组织起来。如果要将category加入到侧边导航栏，需要增加一个aside。
增加aside
复制以下代码到source/_includes/asides/category_list.html。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;Categories&lt;/h1&gt;
</span><span class='line'>  &lt;ul id="categories"&gt;
</span><span class='line'>    {% category_list %}
</span><span class='line'>  &lt;/ul&gt;
</span><span class='line'>&lt;/section&gt;
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>配置侧边栏需要修改_config.yml文件，修改其default_asides项:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default_asides: [asides/category_list.html, asides/recent_posts.html]</span></code></pre></td></tr></table></div></figure>


<h3>6.添加微博秀</h3>

<p>先到微博秀里面生成自己的微博秀嵌入代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;iframe width="100%"
</span><span class='line'> height="550" 
</span><span class='line'> class="share_self"  
</span><span class='line'> frameborder="0" 
</span><span class='line'> scrolling="no" 
</span><span class='line'> src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2
</span><span class='line'>&ptype=1&speed=0&skin=1&isTitle=1&noborder=1
</span><span class='line'>&isWeibo=1&isFans=1&uid=1706688983
</span><span class='line'>&verifier=1a722b18&dpc=1"&gt;
</span><span class='line'>&lt;/iframe&gt;</span></code></pre></td></tr></table></div></figure>


<p>新建一个weibo.html 到source/_include/asides的下面</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>{% if site.weibo_uid %}
</span><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;新浪微博&lt;/h1&gt;
</span><span class='line'>  &lt;ul id="weibo"&gt;
</span><span class='line'>    &lt;li&gt;
</span><span class='line'>      &lt;iframe 
</span><span class='line'>        width="100%" 
</span><span class='line'>        height="550" 
</span><span class='line'>        class="share_self" 
</span><span class='line'>        frameborder="0" 
</span><span class='line'>        scrolling="no" 
</span><span class='line'>        src="http://widget.weibo.com/weiboshow/index.php?width=0&height=550
</span><span class='line'>        &ptype={% if site.weibo_pic %}1{% else %}0{% endif %}&speed=0&skin={{weibo_skin}}&isTitle=0&noborder=1
</span><span class='line'>&isWeibo={% if site.weibo_show %}1{% else %}0{% endif %}&isFans={{weibo_fansline}}&uid={{site.weibo_uid}}&verifier={{site.weibo_verifier}}"&gt;
</span><span class='line'>      &lt;/iframe&gt;
</span><span class='line'>    &lt;/li&gt;
</span><span class='line'>  &lt;/ul&gt;
</span><span class='line'>&lt;/section&gt;
</span><span class='line'>{% endif %}
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>修改_config.xml中default_aside部分</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>... 
</span><span class='line'>default_asides: [asides/recent_posts.html, asides/weibo.html, asides/github.html, asides/[Twitter][].html, asides/googleplus.html]
</span><span class='line'>...
</span><span class='line'>weibo_uid: 1098907490
</span><span class='line'>weibo_verifier: abd54ad9
</span><span class='line'>weibo_fansline: 0   # 粉丝显示多少行
</span><span class='line'>weibo_show: true    # 是否显示最近微博内容
</span><span class='line'>weibo_pic: true     # 是否显示微博中的图片
</span><span class='line'>weibo_skin: 10      # 使用哪种配色风格，数字为从1开始的微博秀风格序号
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<h3>7.评论和分享</h3>

<p>在<em>config.yml中增加一项： weibo_share: true
修改 source/</em>includes/post/sharing.html ，增加：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>{% if site.weibo_share %}
</span><span class='line'>     {% include post/weibo.html %}
</span><span class='line'> {% endif %}
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p>增加文件：source/_includes/post/weibo.html</p>

<p>访问<a href="http://www.jiathis.com/">http://www.jiathis.com/</a> , 获取分享的代码</p>

<p>访问<a href="http://uyan.cc/,">http://uyan.cc/,</a> 获取评论的代码</p>

<p>把代码都加到weibo.html中</p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/" class="prev">Prev</a>
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Shao jie


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






		</div>
	</div>
</body>
</html>
